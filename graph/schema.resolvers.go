package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.31

import (
	"context"
	"errors"
	"log"

	"github.com/Prateek61/go_auth/graph/model"
	"github.com/Prateek61/go_auth/middleware"
)

// CreateTodo is the resolver for the createTodo field.
func (r *mutationResolver) CreateTodo(ctx context.Context, input model.TodoInput) (*model.Todo, error) {
	currentUser, err := middleware.GetCurrentUserFromCTX(ctx)

	if err != nil {
		return nil, ErrUnauthenticated
	}

	todo := &model.Todo{
		Text:   input.Text,
		UserID: currentUser.ID,
	}

	err = r.TodosRepo.CreateTodo(todo)
	return todo, err
}

// Register is the resolver for the register field.
func (r *mutationResolver) Register(ctx context.Context, input *model.RegisterInput) (*model.AuthResponse, error) {
	// Check if user with input.Email exists
	_, err := r.UsersRepo.GetUserByEmail(input.Email)
	if err == nil {
		return nil, errors.New("email already in use")
	}

	_, err = r.UsersRepo.GetUserByUsername(input.Username)
	if err == nil {
		return nil, errors.New("username already in use")
	}

	user := &model.User{
		Username:  input.Username,
		Email:     input.Email,
		FirstName: input.FirstName,
		LastName:  input.LastName,
		DeletedAt: nil,
	}

	err = user.HashPassword(input.Password)
	if err != nil {
		log.Printf("Error hashing password: %v", err)
		return nil, errors.New("something went wrong")
	}

	tx, err := r.UsersRepo.DB.Begin()

	if err != nil {
		log.Printf("Error starting transaction: %v", err)
		return nil, errors.New("something went wrong")
	}
	defer tx.Rollback()

	_, err = r.UsersRepo.CreateUser(tx, user)
	if err != nil {
		log.Printf("Error creating user: %v", err)
		return nil, errors.New("something went wrong")
	}

	err = tx.Commit()
	if err != nil {
		log.Printf("Error committing transaction: %v", err)
		return nil, errors.New("something went wrong")
	}

	token, err := user.GenerateToken()
	if err != nil {
		log.Printf("Error generating token: %v", err)
		return nil, errors.New("something went wrong")
	}

	return &model.AuthResponse{
		User:      user,
		AuthToken: token,
	}, nil
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, input *model.LoginInput) (*model.AuthResponse, error) {
	user, err := r.UsersRepo.GetUserByUsername(input.Username)

	if err != nil {
		return nil, ErrBadCredentials
	}

	err = user.CheckPassword(input.Password)
	if err != nil {
		return nil, ErrBadCredentials
	}

	token, err := user.GenerateToken()
	if err != nil {
		return nil, errors.New("something went wrong")
	}

	return &model.AuthResponse{
		User:      user,
		AuthToken: token,
	}, nil
}

// Todos is the resolver for the todos field.
func (r *queryResolver) Todos(ctx context.Context) ([]*model.Todo, error) {
	currentUser, err := middleware.GetCurrentUserFromCTX(ctx)

	if err != nil {
		return nil, ErrUnauthenticated
	}

	return r.TodosRepo.GetTodosByUserID(currentUser.ID)
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context) (*model.User, error) {
	currentUser, err := middleware.GetCurrentUserFromCTX(ctx)

	if err != nil {
		return nil, ErrUnauthenticated
	}

	return currentUser, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
